// filepath: scripts/generate-sidebar.js
const fs = require('fs');
const path = require('path');

const DOCS_PATH = path.resolve(__dirname, '../public/docs');
const OUTPUT_PATH = path.resolve(__dirname, '../src/sidebar.data.js');

function formatName(name) {
  // 移除 .md 后缀 (如果存在，尽管通常在此阶段已移除)
  let formatted = name.replace(/\.md$/i, '');
  // 将破折号和下划线替换为空格
  formatted = formatted.replace(/[-_]/g, ' ');
  // 将每个单词的首字母大写
  formatted = formatted.replace(/\b\w/g, char => char.toUpperCase());
  return formatted;
}

function generateSidebarItems(currentDirPath, baseDocsPath) {
  const items = [];
  let entries;
  try {
    entries = fs.readdirSync(currentDirPath, { withFileTypes: true });
  } catch (error) {
    console.error(`Error reading directory ${currentDirPath}:`, error);
    return []; // Return empty if directory can't be read
  }

  // 排序：文件夹优先，然后是文件，均按字母顺序
  entries.sort((a, b) => {
    if (a.isDirectory() && !b.isDirectory()) return -1;
    if (!a.isDirectory() && b.isDirectory()) return 1;
    return a.name.localeCompare(b.name);
  });

  for (const entry of entries) {
    const fullEntryPath = path.join(currentDirPath, entry.name);
    // 相对于 public/docs 的路径，并移除 .md 后缀
    const relativePath = path.relative(baseDocsPath, fullEntryPath).replace(/\\/g, '/');

    if (entry.isDirectory()) {
      const children = generateSidebarItems(fullEntryPath, baseDocsPath);
      if (children.length > 0) {
        items.push({
          name: formatName(entry.name), // e.g., "Guide"
          children: children,
        });
      }
    } else if (entry.isFile() && entry.name.toLowerCase().endsWith('.md')) {
      const fileNameWithoutExt = entry.name.substring(0, entry.name.length - 3);
      const itemPath = relativePath.substring(0, relativePath.length - 3);

      // 特殊处理根目录下的 README.md
      if (currentDirPath === baseDocsPath && fileNameWithoutExt.toLowerCase() === 'readme') {
        // 由主调用逻辑处理为 "首页"
        items.push({
          name: '首页', // 将被主逻辑使用
          path: itemPath, // "README"
          isRootReadme: true, // 标记，以便后续处理
        });
      } else if (fileNameWithoutExt.toLowerCase() !== 'readme') {
        // 非 README 文件，或子目录中的 README 文件（如果希望它们显示为普通页面）
        // 如果不希望子目录的 README.md 显示，可以在这里过滤掉
        //  if (fileNameWithoutExt.toLowerCase() === 'readme') continue;
        items.push({
          name: formatName(fileNameWithoutExt),
          path: itemPath,
        });
      }
      // 注意：当前逻辑下，子目录中的 README.md 如果不是被特别处理，
      // 且没有被上面的 if (fileNameWithoutExt.toLowerCase() !== 'readme') 排除，
      // 它会被格式化为 "Readme"。
      // 如果子目录的 README.md 不应成为单独的导航项，请取消注释上面的 continue 语句。
      // 或者，如果它应该作为其父目录的索引页，则此处的逻辑需要调整，
      // 但通常父目录本身（如 "Guide"）就代表了这个分组。
    }
  }
  return items;
}

console.log('Generating sidebar data...');
const allGeneratedItems = generateSidebarItems(DOCS_PATH, DOCS_PATH);

let finalSidebarItems = [];

// 1. 处理根 README (首页)
const rootReadmeIndex = allGeneratedItems.findIndex(item => item.isRootReadme);
if (rootReadmeIndex > -1) {
  const rootReadmeItem = allGeneratedItems.splice(rootReadmeIndex, 1)[0];
  finalSidebarItems.push({ name: "首页", path: rootReadmeItem.path });
}

// 2. 对剩余的顶层项目（文件夹和其他md文件）进行排序
// 您可以根据需要自定义此排序逻辑，例如，确保 "指南" 在 "API 文档" 之前
const desiredOrder = ["Guide", "Api"]; // 根据 formatName 后的文件夹名

allGeneratedItems.sort((a, b) => {
  const aName = a.name; // 已经是格式化后的名称
  const bName = b.name;

  const indexA = desiredOrder.indexOf(aName);
  const indexB = desiredOrder.indexOf(bName);

  if (indexA !== -1 && indexB !== -1) { // 都在期望顺序列表中
    return indexA - indexB;
  }
  if (indexA !== -1) return -1; // a 在期望顺序中，b 不在
  if (indexB !== -1) return 1;  // b 在期望顺序中，a 不在

  // 对于不在期望顺序列表中的项，按字母顺序排序
  return aName.localeCompare(bName);
});

finalSidebarItems = finalSidebarItems.concat(allGeneratedItems);


const fileContent = `// This file is auto-generated by scripts/generate-sidebar.js
// Do not edit this file directly.

export default ${JSON.stringify(finalSidebarItems, null, 2)};
`;

try {
  fs.writeFileSync(OUTPUT_PATH, fileContent, 'utf8');
  console.log(`Sidebar data successfully generated at ${OUTPUT_PATH}`);
} catch (error) {
  console.error('Error writing sidebar data file:', error);
}